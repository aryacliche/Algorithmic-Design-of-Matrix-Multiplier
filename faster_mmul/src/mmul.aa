$parameter ORDER 16

$storage A B C: $array[ORDER][ORDER] $of $uint<32>

$module [storeA] $in (I J: $uint<8> wval: $uint<32>) $out () $is
{
	A[I][J] := wval
}
$module [storeB] $in (I J: $uint<8> wval: $uint<32>) $out () $is
{
	B[I][J] := wval
}

$module [loadC] $in (I J : $uint<8>) $out (Y : $uint<32>) $is
{
	Y := C[I][J]
}

$module [dot_product_most_expensive] $in (I J: $uint<8>) $out (result: $uint<32>) $is
{
	// This is tailored for ORDER = 16. There is a lot of parallelism thus.
	$parallelblock [p1]
	{
		prod0 := (A[I][0] * B[0][J])
		prod1 := (A[I][1] * B[1][J])
		prod2 := (A[I][2] * B[2][J])
		prod3 := (A[I][3] * B[3][J])
		prod4 := (A[I][4] * B[4][J])
		prod5 := (A[I][5] * B[5][J])
		prod6 := (A[I][6] * B[6][J])
		prod7 := (A[I][7] * B[7][J])
		prod8 := (A[I][8] * B[8][J])
		prod9 := (A[I][9] * B[9][J])
		prod10 := (A[I][10] * B[10][J])
		prod11 := (A[I][11] * B[11][J])
		prod12 := (A[I][12] * B[12][J])
		prod13 := (A[I][13] * B[13][J])
		prod14 := (A[I][14] * B[14][J])
		prod15 := (A[I][15] * B[15][J])
	}(  prod0 => prod0
		prod1 => prod1
		prod2 => prod2
		prod3 => prod3
		prod4 => prod4
		prod5 => prod5
		prod6 => prod6
		prod7 => prod7
		prod8 => prod8
		prod9 => prod9
		prod10 => prod10
		prod11 => prod11
		prod12 => prod12
		prod13 => prod13
		prod14 => prod14
		prod15 => prod15)
	$volatile result := (
		( ((prod1 + prod2) + (prod3 + prod4)) + ((prod5 + prod6) + (prod7 + prod8)) ) 
		+
		( ((prod9 + prod10) + (prod11 + prod12)) + ((prod13 + prod14) + (prod15 + prod0)) )
		)
}

$module [dot_product_forked] $in (I J: $uint<8>) $out (result: $uint<32>) $is
{
	// This is tailored for ORDER = 16. There is a lot of parallelism thus.
	$forkblock [f1]
	{
		$parallelblock [p1]
		{
			prod1 := (A[I][1] * B[1][J])
			prod2 := (A[I][2] * B[2][J])
		} (	prod1
			prod2)
		$parallelblock [p2]
		{
			prod3 := (A[I][3] * B[3][J])
			prod4 := (A[I][4] * B[4][J])
		} (	prod3
			prod4)
		$parallelblock [p3]
		{
			prod5 := (A[I][5] * B[5][J])
			prod6 := (A[I][6] * B[6][J])
		} (	prod5
			prod6)
		$parallelblock [p4]
		{
			prod7 := (A[I][7] * B[7][J])
			prod8 := (A[I][8] * B[8][J])
		} (	prod7
			prod8)
		$parallelblock [p5]
		{
			prod9 := (A[I][9] * B[9][J])
			prod10 := (A[I][10] * B[10][J])
		} (	prod9
			prod10)
		$parallelblock [p6]
		{
			prod11 := (A[I][11] * B[11][J])
			prod12 := (A[I][12] * B[12][J])
		} (	prod11
			prod12)
		$parallelblock [p7]
		{		
			prod13 := (A[I][13] * B[13][J])
			prod14 := (A[I][14] * B[14][J])
		} ( prod13
			prod14)
		$parallelblock [p8]
		{		
			prod15 := (A[I][15] * B[15][J])
			prod0 := (A[I][0] * B[0][J])
		} (	prod15
			prod0)
		
		$join p1 p2 $fork $parallelblock [s1] { 
			sum1 := (prod1 + prod2) 
			sum2 := (prod3 + prod4)
		} (	sum1 => sum1
			sum2 => sum2)
		
		$join p3 p4 $fork $parallelblock [s2] { 
			sum3 := (prod5 + prod6)
			sum4 := (prod7 + prod8)
		} (	sum3 => sum3
			sum4 => sum4)

		$join p5 p6 $fork $parallelblock [s3] { 
			sum5 := (prod9 + prod10)
			sum6 := (prod11 + prod12)
		} (	sum5 => sum5
			sum6 => sum6)

		$join p7 p8 $fork $parallelblock [s4] { 
			sum7 := (prod13 + prod14)
			sum8 := (prod15 + prod0)
		} (	sum7 => sum7
			sum8 => sum8)

		$join s1 s2 $fork $seriesblock [su1] { ssum1 := (sum1 + sum2) } (ssum1 => ssum1)
		$join s3 s4 $fork $seriesblock [su2] { ssum2 := (sum3 + sum4) } (ssum2 => ssum2)
	} (ssum1 => ssum1 ssum2 => ssum2)
	$volatile result := ( ssum1 + ssum2 )
}


$module [dot_product_unrolled] $in (I J: $uint<8>) $out (result: $uint<32>) $is
{
	$branchblock[loop] {

		$dopipeline $depth 31 $fullrate
			$merge $entry $loopback
				$phi K := $zero<8> $on $entry nK $on $loopback
				$phi SUM0 := ($bitcast ($uint<32>) 0)  $on $entry nSUM0 $on $loopback
				$phi SUM1 := ($bitcast ($uint<32>) 0)  $on $entry nSUM1 $on $loopback
			$endmerge
			$volatile nK := (K + 2)
			$volatile continue_flag := (K < (ORDER-2))

			nSUM0 := (SUM0 + (A[I][K] * B[K][J]))
			nSUM1 := (SUM1 + (A[I][(K+1)] * B[(K+1)][J]))
		$while continue_flag
		$volatile fSUM := (nSUM0 + nSUM1)
	} (fSUM => result_exported)
	$volatile result := result_exported
}

$module [dot_product] $in (I J: $uint<8>) $out (result: $uint<32>) $is
{
	$branchblock[loop] {

		$dopipeline $depth 31 $fullrate
			$merge $entry $loopback
				$phi K := $zero<8> $on $entry nK $on $loopback
				$phi SUM := ($bitcast ($uint<32>) 0)  $on $entry nSUM $on $loopback
			$endmerge
			$volatile nK := (K + 1)
			$volatile continue_flag := (K < (ORDER-1))

			nSUM := (SUM + (A[I][K] * B[K][J]))
		$while continue_flag
	} (nSUM => result_exported)
	$volatile result := result_exported
}

$module [mmul] $in () $out () $is
{
	$branchblock[loop] {
	    $merge $entry I_loopback 
			$phi I := $zero<8> $on $entry nI $on I_loopback
		$endmerge
		$volatile nI := (I + 1)

		$dopipeline $depth 3 
			$merge $entry $loopback 
				$phi J := $zero<8> $on $entry nJ $on $loopback
			$endmerge
			$volatile nJ := (J + 1)
			$volatile continue_flag := (J < (ORDER - 1))
	
			// dot-product.. naive implementation.
			//C[I][J] := ($call dot_product (I J))
		
			// Use the unrolled version to speed things up.
			//C[I][J] := ($call dot_product_unrolled (I J))

			// Use the expensive version to speed things up even more.
			C[I][J] := ($call dot_product_most_expensive (I J))
			
		$while continue_flag

	    $if (I < (ORDER-1)) $then $place [I_loopback] $endif
	}
}

$module [latencyTest] $in () $out () $is
{
	// This module is just here so that we can look at how much time it takes for a call to HW from C takes.
	$null
}