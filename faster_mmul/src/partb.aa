$parameter ORDER 16
$constant ZERO_8 : $uint<8> := 0
$constant ONE_8 : $uint<8> := 1
$constant TWO_8 : $uint<8> := 2
$constant THREE_8 : $uint<8> := 3
$constant FOUR_8 : $uint<8> := 4
$constant FIVE_8 : $uint<8> := 5
$constant SIX_8 : $uint<8> := 6
$constant SEVEN_8 : $uint<8> := 7

$storage A B: $array[ORDER][ORDER] $of $uint<32>
$storage C_0, C_1, C_2, C_3, C_4, C_5, C_6, C_7: $array[{ORDER / 2}][{ORDER / 2}] $of $uint<32> // C_{} is a collection of 8 arrays of sizes ORDER/2 x ORDER/2
// The way this

$module [storeA] $in (I J: $uint<8> wval: $uint<32>) $out () $is
{
	A[I][J] := wval
}
$module [storeB] $in (I J: $uint<8> wval: $uint<32>) $out () $is
{
	B[I][J] := wval
}

$module [loadC] $in (I J : $uint<8>) $out (Y : $uint<32>) $is
{
	Y := ($excmux
		 	((I < 8) & (J < 8)) 	C_0[I][J]
		 	((I < 8) & (J >= 8)) 	C_1[I][(J - 8)]
			((I >= 8) & (J < 8)) 	C_2[(I - 8)][J]
			((I >= 8) & (J >= 8)) 	C_3[(I - 8)][(J - 8)]
		)
}

#define MMUL_UNIT	mmul_8_0
#define A_COL_B_ROW	0
#define A_ROW	0
#define B_COL	0
#include utils_mmul_partb.aa

#define MMUL_UNIT	mmul_8_1
#define A_COL_B_ROW	0
#define A_ROW	0
#define B_COL	1
#include utils_mmul_partb.aa

#define MMUL_UNIT	mmul_8_2
#define A_COL_B_ROW	0
#define A_ROW	1
#define B_COL	0
#include utils_mmul_partb.aa

#define MMUL_UNIT	mmul_8_3
#define A_COL_B_ROW	0
#define A_ROW	1
#define B_COL	1
#include utils_mmul_partb.aa

#define MMUL_UNIT	mmul_8_4
#define A_COL_B_ROW	1
#define A_ROW	0
#define B_COL	0
#include utils_mmul_partb.aa

#define MMUL_UNIT	mmul_8_5
#define A_COL_B_ROW	1
#define A_ROW	0
#define B_COL	1
#include utils_mmul_partb.aa

#define MMUL_UNIT	mmul_8_6
#define A_COL_B_ROW	1
#define A_ROW	1
#define B_COL	0
#include utils_mmul_partb.aa

#define MMUL_UNIT	mmul_8_7
#define A_COL_B_ROW	1
#define A_ROW	1
#define B_COL	1
#include utils_mmul_partb.aa

#define SUBMATRIX_ADDER_MODULE	add_submatrices_0
#define index1	0
#define index2	4
#include utils_adder_partb.aa

#define SUBMATRIX_ADDER_MODULE	add_submatrices_1
#define index1	1
#define index2	5
#include utils_adder_partb.aa

#define SUBMATRIX_ADDER_MODULE	add_submatrices_2
#define index1	2
#define index2	6
#include utils_adder_partb.aa

#define SUBMATRIX_ADDER_MODULE	add_submatrices_3
#define index1	3
#define index2	7
#include utils_adder_partb.aa

$module [mmul] $in () $out () $is
{
	$parallelblock[p1] 
	{
		$call mmul_8_0 () ()
		$call mmul_8_1 () ()
		$call mmul_8_2 () ()
		$call mmul_8_3 () ()
		$call mmul_8_4 () ()
		$call mmul_8_5 () ()
		$call mmul_8_6 () ()
		$call mmul_8_7 () ()
	}
	$parallelblock[p2]
	{
		$call add_submatrices_0 () ()
		$call add_submatrices_1 () ()
		$call add_submatrices_2 () ()
		$call add_submatrices_3 () ()
	}
}

$module [latencyTest] $in () $out () $is
{
	// This module is just here so that we can look at how much time it takes for a call to HW from C takes.
	$null
}

$pipe COUNT_SIGNAL: $uint<32> $depth 1 $signal

$module [counter_daemon]
	$in () $out () $is
{
	$branchblock[loop] {
		$dopipeline $depth 7 $fullrate
		$merge $entry $loopback
			$phi counter := $zero<32> $on $entry n_counter $on $loopback
		$endmerge
		$volatile n_counter := (counter + 1)
		COUNT_SIGNAL := counter
		$while 1
	}
}

$module [readCounter] $in () $out (count_value: $uint<32>) $is
{
	count_value := COUNT_SIGNAL
}
