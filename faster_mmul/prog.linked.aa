$storage  A : $array[16][16] $of $uint<32> // memory space index = 0  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  B : $array[16][16] $of $uint<32> // memory space index = 1  base address = 0  word size = 32
// can point into  foreign( $void )
$pipe  COUNT_SIGNAL : $uint<32>  $depth 1  $signal 
// can point into 
$storage  C_0 : $array[8][8] $of $uint<32> // memory space index = 2  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  C_1 : $array[8][8] $of $uint<32> // memory space index = 3  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  C_2 : $array[8][8] $of $uint<32> // memory space index = 4  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  C_3 : $array[8][8] $of $uint<32> // memory space index = 5  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  C_4 : $array[8][8] $of $uint<32> // memory space index = 6  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  C_5 : $array[8][8] $of $uint<32> // memory space index = 7  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  C_6 : $array[8][8] $of $uint<32> // memory space index = 8  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  C_7 : $array[8][8] $of $uint<32> // memory space index = 9  base address = 0  word size = 32
// can point into  foreign( $void )
$constant  FIVE_8 : $uint<8>:= 5  
$constant  FOUR_8 : $uint<8>:= 4  
$constant  ONE_8 : $uint<8>:= 1  
$constant  SEVEN_8 : $uint<8>:= 7  
$constant  SIX_8 : $uint<8>:= 6  
$constant  THREE_8 : $uint<8>:= 3  
$constant  TWO_8 : $uint<8>:= 2  
$constant  ZERO_8 : $uint<8>:= 0  
$module [add_submatrices_0]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $dopipeline $depth 31 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi J := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nJ $on   $loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nJ := (J + 1 ) $buffering 1
    $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
    C_0[I][J] := (C_0[I][J] + C_4[I][J]) $buffering 1// bits of buffering = 32. 
    $while continue_flag
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [add_submatrices_1]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $dopipeline $depth 31 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi J := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nJ $on   $loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nJ := (J + 1 ) $buffering 1
    $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
    C_1[I][J] := (C_1[I][J] + C_5[I][J]) $buffering 1// bits of buffering = 32. 
    $while continue_flag
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [add_submatrices_2]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $dopipeline $depth 31 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi J := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nJ $on   $loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nJ := (J + 1 ) $buffering 1
    $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
    C_2[I][J] := (C_2[I][J] + C_6[I][J]) $buffering 1// bits of buffering = 32. 
    $while continue_flag
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [add_submatrices_3]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $dopipeline $depth 31 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi J := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nJ $on   $loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nJ := (J + 1 ) $buffering 1
    $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
    C_3[I][J] := (C_3[I][J] + C_7[I][J]) $buffering 1// bits of buffering = 32. 
    $while continue_flag
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [counter_daemon]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $dopipeline $depth 7 $buffering 1
    $fullrate 
    $merge $entry $loopback 
    $phi counter := 			  ($bitcast ($uint<32>) _b0 ) $on   $entry 			  n_counter $on   $loopback 
    // type of target is $uint<32>
    $endmerge
    $volatile n_counter := (counter + 1 ) $buffering 1
    COUNT_SIGNAL := counter $buffering 1// bits of buffering = 32. 
    $while 1 
  }
}
$module [global_storage_initializer_]
$in ()
$out ()
$is
{
  $null
}
$module [latencyTest]
$in ()
$out ()
$is
{
  $null
}
$module [loadC]
$in ( I : $uint<8>   J : $uint<8>  )
$out ( Y : $uint<32>  )
$is
{
  Y := ((( $mux ((I < 8 ) & (J < 8 )) C_0[I][J]  _b0  )  | ( $mux ((I < 8 ) & (J >= 8 )) C_1[I][(J - 8 )]  _b0  ) ) | (( $mux ((I >= 8 ) & (J < 8 )) C_2[(I - 8 )][J]  _b0  )  | ( $mux ((I >= 8 ) & (J >= 8 )) C_3[(I - 8 )][(J - 8 )]  _b0  ) )) $buffering 1// bits of buffering = 32. 
}
$module [mmul_8_0]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $branchblock [loop2]
    {
      $merge $entry J_loopback 
      $phi J := 				  ($bitcast ($uint<8>) _b0 ) $on   $entry 				  nJ $on   J_loopback 
      // type of target is $uint<8>
      $endmerge
      $volatile nJ := (J + 1 ) $buffering 1
      $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
      $volatile A_row_index := I $buffering 1
      $volatile B_col_index := J $buffering 1
      $volatile suffix := ZERO_8 $buffering 1
      $parallelblock[p1]
      {
        prod0 := (A[A_row_index][(suffix + 0 )] * B[(suffix + 0 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod1 := (A[A_row_index][(suffix + 1 )] * B[(suffix + 1 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod2 := (A[A_row_index][(suffix + 2 )] * B[(suffix + 2 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod3 := (A[A_row_index][(suffix + 3 )] * B[(suffix + 3 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod4 := (A[A_row_index][(suffix + 4 )] * B[(suffix + 4 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod5 := (A[A_row_index][(suffix + 5 )] * B[(suffix + 5 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod6 := (A[A_row_index][(suffix + 6 )] * B[(suffix + 6 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod7 := (A[A_row_index][(suffix + 7 )] * B[(suffix + 7 )][B_col_index]) $buffering 1// bits of buffering = 32. 
      }
      ( prod0 => prod0  prod1 => prod1  prod2 => prod2  prod3 => prod3  prod4 => prod4  prod5 => prod5  prod6 => prod6  prod7 => prod7 )
      C_0[I][J] := (((prod0 + prod1) + (prod2 + prod3)) + ((prod4 + prod5) + (prod6 + prod7))) $buffering 1// bits of buffering = 32. 
      $if (J < ((16 / 2 ) - 1 )) $then 
      $place[J_loopback]
      $endif
    }
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [mmul_8_1]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $branchblock [loop2]
    {
      $merge $entry J_loopback 
      $phi J := 				  ($bitcast ($uint<8>) _b0 ) $on   $entry 				  nJ $on   J_loopback 
      // type of target is $uint<8>
      $endmerge
      $volatile nJ := (J + 1 ) $buffering 1
      $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
      $volatile A_row_index := I $buffering 1
      $volatile B_col_index := (J + 8 ) $buffering 1
      $volatile suffix := ZERO_8 $buffering 1
      $parallelblock[p1]
      {
        prod0 := (A[A_row_index][(suffix + 0 )] * B[(suffix + 0 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod1 := (A[A_row_index][(suffix + 1 )] * B[(suffix + 1 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod2 := (A[A_row_index][(suffix + 2 )] * B[(suffix + 2 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod3 := (A[A_row_index][(suffix + 3 )] * B[(suffix + 3 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod4 := (A[A_row_index][(suffix + 4 )] * B[(suffix + 4 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod5 := (A[A_row_index][(suffix + 5 )] * B[(suffix + 5 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod6 := (A[A_row_index][(suffix + 6 )] * B[(suffix + 6 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod7 := (A[A_row_index][(suffix + 7 )] * B[(suffix + 7 )][B_col_index]) $buffering 1// bits of buffering = 32. 
      }
      ( prod0 => prod0  prod1 => prod1  prod2 => prod2  prod3 => prod3  prod4 => prod4  prod5 => prod5  prod6 => prod6  prod7 => prod7 )
      C_1[I][J] := (((prod0 + prod1) + (prod2 + prod3)) + ((prod4 + prod5) + (prod6 + prod7))) $buffering 1// bits of buffering = 32. 
      $if (J < ((16 / 2 ) - 1 )) $then 
      $place[J_loopback]
      $endif
    }
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [mmul_8_2]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $branchblock [loop2]
    {
      $merge $entry J_loopback 
      $phi J := 				  ($bitcast ($uint<8>) _b0 ) $on   $entry 				  nJ $on   J_loopback 
      // type of target is $uint<8>
      $endmerge
      $volatile nJ := (J + 1 ) $buffering 1
      $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
      $volatile A_row_index := (I + 8 ) $buffering 1
      $volatile B_col_index := J $buffering 1
      $volatile suffix := ZERO_8 $buffering 1
      $parallelblock[p1]
      {
        prod0 := (A[A_row_index][(suffix + 0 )] * B[(suffix + 0 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod1 := (A[A_row_index][(suffix + 1 )] * B[(suffix + 1 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod2 := (A[A_row_index][(suffix + 2 )] * B[(suffix + 2 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod3 := (A[A_row_index][(suffix + 3 )] * B[(suffix + 3 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod4 := (A[A_row_index][(suffix + 4 )] * B[(suffix + 4 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod5 := (A[A_row_index][(suffix + 5 )] * B[(suffix + 5 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod6 := (A[A_row_index][(suffix + 6 )] * B[(suffix + 6 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod7 := (A[A_row_index][(suffix + 7 )] * B[(suffix + 7 )][B_col_index]) $buffering 1// bits of buffering = 32. 
      }
      ( prod0 => prod0  prod1 => prod1  prod2 => prod2  prod3 => prod3  prod4 => prod4  prod5 => prod5  prod6 => prod6  prod7 => prod7 )
      C_2[I][J] := (((prod0 + prod1) + (prod2 + prod3)) + ((prod4 + prod5) + (prod6 + prod7))) $buffering 1// bits of buffering = 32. 
      $if (J < ((16 / 2 ) - 1 )) $then 
      $place[J_loopback]
      $endif
    }
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [mmul_8_3]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $branchblock [loop2]
    {
      $merge $entry J_loopback 
      $phi J := 				  ($bitcast ($uint<8>) _b0 ) $on   $entry 				  nJ $on   J_loopback 
      // type of target is $uint<8>
      $endmerge
      $volatile nJ := (J + 1 ) $buffering 1
      $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
      $volatile A_row_index := (I + 8 ) $buffering 1
      $volatile B_col_index := (J + 8 ) $buffering 1
      $volatile suffix := ZERO_8 $buffering 1
      $parallelblock[p1]
      {
        prod0 := (A[A_row_index][(suffix + 0 )] * B[(suffix + 0 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod1 := (A[A_row_index][(suffix + 1 )] * B[(suffix + 1 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod2 := (A[A_row_index][(suffix + 2 )] * B[(suffix + 2 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod3 := (A[A_row_index][(suffix + 3 )] * B[(suffix + 3 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod4 := (A[A_row_index][(suffix + 4 )] * B[(suffix + 4 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod5 := (A[A_row_index][(suffix + 5 )] * B[(suffix + 5 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod6 := (A[A_row_index][(suffix + 6 )] * B[(suffix + 6 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod7 := (A[A_row_index][(suffix + 7 )] * B[(suffix + 7 )][B_col_index]) $buffering 1// bits of buffering = 32. 
      }
      ( prod0 => prod0  prod1 => prod1  prod2 => prod2  prod3 => prod3  prod4 => prod4  prod5 => prod5  prod6 => prod6  prod7 => prod7 )
      C_3[I][J] := (((prod0 + prod1) + (prod2 + prod3)) + ((prod4 + prod5) + (prod6 + prod7))) $buffering 1// bits of buffering = 32. 
      $if (J < ((16 / 2 ) - 1 )) $then 
      $place[J_loopback]
      $endif
    }
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [mmul_8_4]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $branchblock [loop2]
    {
      $merge $entry J_loopback 
      $phi J := 				  ($bitcast ($uint<8>) _b0 ) $on   $entry 				  nJ $on   J_loopback 
      // type of target is $uint<8>
      $endmerge
      $volatile nJ := (J + 1 ) $buffering 1
      $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
      $volatile A_row_index := I $buffering 1
      $volatile B_col_index := J $buffering 1
      $volatile suffix := ONE_8 $buffering 1
      $parallelblock[p1]
      {
        prod0 := (A[A_row_index][(suffix + 0 )] * B[(suffix + 0 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod1 := (A[A_row_index][(suffix + 1 )] * B[(suffix + 1 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod2 := (A[A_row_index][(suffix + 2 )] * B[(suffix + 2 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod3 := (A[A_row_index][(suffix + 3 )] * B[(suffix + 3 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod4 := (A[A_row_index][(suffix + 4 )] * B[(suffix + 4 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod5 := (A[A_row_index][(suffix + 5 )] * B[(suffix + 5 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod6 := (A[A_row_index][(suffix + 6 )] * B[(suffix + 6 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod7 := (A[A_row_index][(suffix + 7 )] * B[(suffix + 7 )][B_col_index]) $buffering 1// bits of buffering = 32. 
      }
      ( prod0 => prod0  prod1 => prod1  prod2 => prod2  prod3 => prod3  prod4 => prod4  prod5 => prod5  prod6 => prod6  prod7 => prod7 )
      C_4[I][J] := (((prod0 + prod1) + (prod2 + prod3)) + ((prod4 + prod5) + (prod6 + prod7))) $buffering 1// bits of buffering = 32. 
      $if (J < ((16 / 2 ) - 1 )) $then 
      $place[J_loopback]
      $endif
    }
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [mmul_8_5]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $branchblock [loop2]
    {
      $merge $entry J_loopback 
      $phi J := 				  ($bitcast ($uint<8>) _b0 ) $on   $entry 				  nJ $on   J_loopback 
      // type of target is $uint<8>
      $endmerge
      $volatile nJ := (J + 1 ) $buffering 1
      $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
      $volatile A_row_index := I $buffering 1
      $volatile B_col_index := (J + 8 ) $buffering 1
      $volatile suffix := ONE_8 $buffering 1
      $parallelblock[p1]
      {
        prod0 := (A[A_row_index][(suffix + 0 )] * B[(suffix + 0 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod1 := (A[A_row_index][(suffix + 1 )] * B[(suffix + 1 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod2 := (A[A_row_index][(suffix + 2 )] * B[(suffix + 2 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod3 := (A[A_row_index][(suffix + 3 )] * B[(suffix + 3 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod4 := (A[A_row_index][(suffix + 4 )] * B[(suffix + 4 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod5 := (A[A_row_index][(suffix + 5 )] * B[(suffix + 5 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod6 := (A[A_row_index][(suffix + 6 )] * B[(suffix + 6 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod7 := (A[A_row_index][(suffix + 7 )] * B[(suffix + 7 )][B_col_index]) $buffering 1// bits of buffering = 32. 
      }
      ( prod0 => prod0  prod1 => prod1  prod2 => prod2  prod3 => prod3  prod4 => prod4  prod5 => prod5  prod6 => prod6  prod7 => prod7 )
      C_5[I][J] := (((prod0 + prod1) + (prod2 + prod3)) + ((prod4 + prod5) + (prod6 + prod7))) $buffering 1// bits of buffering = 32. 
      $if (J < ((16 / 2 ) - 1 )) $then 
      $place[J_loopback]
      $endif
    }
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [mmul_8_6]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $branchblock [loop2]
    {
      $merge $entry J_loopback 
      $phi J := 				  ($bitcast ($uint<8>) _b0 ) $on   $entry 				  nJ $on   J_loopback 
      // type of target is $uint<8>
      $endmerge
      $volatile nJ := (J + 1 ) $buffering 1
      $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
      $volatile A_row_index := (I + 8 ) $buffering 1
      $volatile B_col_index := J $buffering 1
      $volatile suffix := ONE_8 $buffering 1
      $parallelblock[p1]
      {
        prod0 := (A[A_row_index][(suffix + 0 )] * B[(suffix + 0 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod1 := (A[A_row_index][(suffix + 1 )] * B[(suffix + 1 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod2 := (A[A_row_index][(suffix + 2 )] * B[(suffix + 2 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod3 := (A[A_row_index][(suffix + 3 )] * B[(suffix + 3 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod4 := (A[A_row_index][(suffix + 4 )] * B[(suffix + 4 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod5 := (A[A_row_index][(suffix + 5 )] * B[(suffix + 5 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod6 := (A[A_row_index][(suffix + 6 )] * B[(suffix + 6 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod7 := (A[A_row_index][(suffix + 7 )] * B[(suffix + 7 )][B_col_index]) $buffering 1// bits of buffering = 32. 
      }
      ( prod0 => prod0  prod1 => prod1  prod2 => prod2  prod3 => prod3  prod4 => prod4  prod5 => prod5  prod6 => prod6  prod7 => prod7 )
      C_6[I][J] := (((prod0 + prod1) + (prod2 + prod3)) + ((prod4 + prod5) + (prod6 + prod7))) $buffering 1// bits of buffering = 32. 
      $if (J < ((16 / 2 ) - 1 )) $then 
      $place[J_loopback]
      $endif
    }
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [mmul_8_7]
$in ()
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $branchblock [loop2]
    {
      $merge $entry J_loopback 
      $phi J := 				  ($bitcast ($uint<8>) _b0 ) $on   $entry 				  nJ $on   J_loopback 
      // type of target is $uint<8>
      $endmerge
      $volatile nJ := (J + 1 ) $buffering 1
      $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
      $volatile A_row_index := (I + 8 ) $buffering 1
      $volatile B_col_index := (J + 8 ) $buffering 1
      $volatile suffix := ONE_8 $buffering 1
      $parallelblock[p1]
      {
        prod0 := (A[A_row_index][(suffix + 0 )] * B[(suffix + 0 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod1 := (A[A_row_index][(suffix + 1 )] * B[(suffix + 1 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod2 := (A[A_row_index][(suffix + 2 )] * B[(suffix + 2 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod3 := (A[A_row_index][(suffix + 3 )] * B[(suffix + 3 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod4 := (A[A_row_index][(suffix + 4 )] * B[(suffix + 4 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod5 := (A[A_row_index][(suffix + 5 )] * B[(suffix + 5 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod6 := (A[A_row_index][(suffix + 6 )] * B[(suffix + 6 )][B_col_index]) $buffering 1// bits of buffering = 32. 
        prod7 := (A[A_row_index][(suffix + 7 )] * B[(suffix + 7 )][B_col_index]) $buffering 1// bits of buffering = 32. 
      }
      ( prod0 => prod0  prod1 => prod1  prod2 => prod2  prod3 => prod3  prod4 => prod4  prod5 => prod5  prod6 => prod6  prod7 => prod7 )
      C_7[I][J] := (((prod0 + prod1) + (prod2 + prod3)) + ((prod4 + prod5) + (prod6 + prod7))) $buffering 1// bits of buffering = 32. 
      $if (J < ((16 / 2 ) - 1 )) $then 
      $place[J_loopback]
      $endif
    }
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [mmul]
$in ()
$out ()
$is
{
  $parallelblock[p1]
  {
    $call mmul_8_0 () () 
    $call mmul_8_1 () () 
    $call mmul_8_2 () () 
    $call mmul_8_3 () () 
    $call mmul_8_4 () () 
    $call mmul_8_5 () () 
    $call mmul_8_6 () () 
    $call mmul_8_7 () () 
  }
  $parallelblock[p2]
  {
    $call add_submatrices_0 () () 
    $call add_submatrices_1 () () 
    $call add_submatrices_2 () () 
    $call add_submatrices_3 () () 
  }
}
$module [readCounter]
$in ()
$out ( count_value : $uint<32>  )
$is
{
  count_value := COUNT_SIGNAL $buffering 1// bits of buffering = 32. 
}
$module [storeA]
$in ( I : $uint<8>   J : $uint<8>   wval : $uint<32>  )
$out ()
$is
{
  A[I][J] := wval $buffering 1// bits of buffering = 32. 
}
$module [storeB]
$in ( I : $uint<8>   J : $uint<8>   wval : $uint<32>  )
$out ()
$is
{
  B[I][J] := wval $buffering 1// bits of buffering = 32. 
}
// Memory space 0: A 
// Memory space 1: B 
// Memory space 2: C_0 
// Memory space 3: C_1 
// Memory space 4: C_2 
// Memory space 5: C_3 
// Memory space 6: C_4 
// Memory space 7: C_5 
// Memory space 8: C_6 
// Memory space 9: C_7 
// use of gated clocks in modules 
