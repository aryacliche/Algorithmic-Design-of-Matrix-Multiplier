$storage  A : $array[16][16] $of $uint<32> // memory space index = 0  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  B : $array[16][16] $of $uint<32> // memory space index = 1  base address = 0  word size = 32
// can point into  foreign( $void )
$storage  C_temp : $array[8][8][8] $of $uint<32> // memory space index = 2  base address = 0  word size = 32
// can point into  foreign( $void )
$module [add_submatrices]
$in ( index1 : $uint<8>   index2 : $uint<8>  )
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $dopipeline $depth 3 $buffering 1
    $merge $entry $loopback 
    $phi J := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nJ $on   $loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nJ := (J + 1 ) $buffering 1
    $volatile continue_flag := (J < ((16 / 2 ) - 1 )) $buffering 1
    C_temp[index1][I][J] := (C_temp[index1][I][J] + C_temp[index2][I][J]) $buffering 1// bits of buffering = 32. 
    $while continue_flag
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [dot_product_fully_unrolled_8]
$in ( I : $uint<8>   J : $uint<8>   A_row : $uint<8>   B_col : $uint<8>   A_col_B_row : $uint<8>  )
$out ()
$is
{
  $parallelblock[p1]
  {
    prod0 := (A[((A_row << 3 ) + I)][((A_col_B_row << 3 ) + 0 )] * B[((A_col_B_row << 3 ) + 0 )][((B_col << 3 ) + J)]) $buffering 1// bits of buffering = 32. 
    prod1 := (A[((A_row << 3 ) + I)][((A_col_B_row << 3 ) + 1 )] * B[((A_col_B_row << 3 ) + 1 )][((B_col << 3 ) + J)]) $buffering 1// bits of buffering = 32. 
    prod2 := (A[((A_row << 3 ) + I)][((A_col_B_row << 3 ) + 2 )] * B[((A_col_B_row << 3 ) + 2 )][((B_col << 3 ) + J)]) $buffering 1// bits of buffering = 32. 
    prod3 := (A[((A_row << 3 ) + I)][((A_col_B_row << 3 ) + 3 )] * B[((A_col_B_row << 3 ) + 3 )][((B_col << 3 ) + J)]) $buffering 1// bits of buffering = 32. 
    prod4 := (A[((A_row << 3 ) + I)][((A_col_B_row << 3 ) + 4 )] * B[((A_col_B_row << 3 ) + 4 )][((B_col << 3 ) + J)]) $buffering 1// bits of buffering = 32. 
    prod5 := (A[((A_row << 3 ) + I)][((A_col_B_row << 3 ) + 5 )] * B[((A_col_B_row << 3 ) + 5 )][((B_col << 3 ) + J)]) $buffering 1// bits of buffering = 32. 
    prod6 := (A[((A_row << 3 ) + I)][((A_col_B_row << 3 ) + 6 )] * B[((A_col_B_row << 3 ) + 6 )][((B_col << 3 ) + J)]) $buffering 1// bits of buffering = 32. 
    prod7 := (A[((A_row << 3 ) + I)][((A_col_B_row << 3 ) + 7 )] * B[((A_col_B_row << 3 ) + 7 )][((B_col << 3 ) + J)]) $buffering 1// bits of buffering = 32. 
  }
  ( prod0 => prod0  prod1 => prod1  prod2 => prod2  prod3 => prod3  prod4 => prod4  prod5 => prod5  prod6 => prod6  prod7 => prod7 )
  C_temp[((((A_col_B_row << 1 ) + A_row) << 1 ) + B_col)][I][J] := (((prod1 + prod2) + (prod3 + prod4)) + ((prod5 + prod6) + (prod7 + prod0))) $buffering 1// bits of buffering = 32. 
}
$module [global_storage_initializer_]
$in ()
$out ()
$is
{
  $null
}
$module [latencyTest]
$in ()
$out ()
$is
{
  $null
}
$module [loadC]
$in ( I : $uint<8>   J : $uint<8>  )
$out ( Y : $uint<32>  )
$is
{
  Y := ((( $mux ((I < 8 ) & (J < 8 )) C_temp[0 ][I][J]  _b0  )  | ( $mux ((I < 8 ) & (J >= 8 )) C_temp[1 ][I][(J - 8 )]  _b0  ) ) | (( $mux ((I >= 8 ) & (J < 8 )) C_temp[2 ][(I - 8 )][J]  _b0  )  | ( $mux ((I >= 8 ) & (J >= 8 )) C_temp[3 ][(I - 8 )][(J - 8 )]  _b0  ) )) $buffering 1// bits of buffering = 32. 
}
$module [mmul_8]
$in ( A_row : $uint<8>   B_col : $uint<8>   A_col_B_row : $uint<8>  )
$out ()
$is
{
  $branchblock [loop]
  {
    $merge $entry I_loopback 
    $phi I := 			  ($bitcast ($uint<8>) _b0 ) $on   $entry 			  nI $on   I_loopback 
    // type of target is $uint<8>
    $endmerge
    $volatile nI := (I + 1 ) $buffering 1
    $branchblock [loop2]
    {
      $merge $entry J_loopback 
      $phi J := 				  ($bitcast ($uint<8>) _b0 ) $on   $entry 				  nJ $on   J_loopback 
      // type of target is $uint<8>
      $endmerge
      $volatile nJ := (J + 1 ) $buffering 1
      $call dot_product_fully_unrolled_8 (I J A_row B_col A_col_B_row ) () 
      $if (J < ((16 / 2 ) - 1 )) $then 
      $place[J_loopback]
      $endif
    }
    $if (I < ((16 / 2 ) - 1 )) $then 
    $place[I_loopback]
    $endif
  }
}
$module [mmul]
$in ()
$out ()
$is
{
  $parallelblock[p1]
  {
    $call mmul_8 (($cast ($uint<8>) 0  ) ($cast ($uint<8>) 0  ) ($cast ($uint<8>) 0  ) ) () 
    $call mmul_8 (($cast ($uint<8>) 0  ) ($cast ($uint<8>) 0  ) ($cast ($uint<8>) 1  ) ) () 
    $call mmul_8 (($cast ($uint<8>) 0  ) ($cast ($uint<8>) 1  ) ($cast ($uint<8>) 0  ) ) () 
    $call mmul_8 (($cast ($uint<8>) 0  ) ($cast ($uint<8>) 1  ) ($cast ($uint<8>) 1  ) ) () 
    $call mmul_8 (($cast ($uint<8>) 1  ) ($cast ($uint<8>) 0  ) ($cast ($uint<8>) 0  ) ) () 
    $call mmul_8 (($cast ($uint<8>) 1  ) ($cast ($uint<8>) 0  ) ($cast ($uint<8>) 1  ) ) () 
    $call mmul_8 (($cast ($uint<8>) 1  ) ($cast ($uint<8>) 1  ) ($cast ($uint<8>) 0  ) ) () 
    $call mmul_8 (($cast ($uint<8>) 1  ) ($cast ($uint<8>) 1  ) ($cast ($uint<8>) 1  ) ) () 
  }
  $parallelblock[p2]
  {
    $call add_submatrices (($cast ($uint<8>) 0  ) ($cast ($uint<8>) 4  ) ) () 
    $call add_submatrices (($cast ($uint<8>) 1  ) ($cast ($uint<8>) 5  ) ) () 
    $call add_submatrices (($cast ($uint<8>) 2  ) ($cast ($uint<8>) 6  ) ) () 
    $call add_submatrices (($cast ($uint<8>) 3  ) ($cast ($uint<8>) 7  ) ) () 
  }
}
$module [storeA]
$in ( I : $uint<8>   J : $uint<8>   wval : $uint<32>  )
$out ()
$is
{
  A[I][J] := wval $buffering 1// bits of buffering = 32. 
}
$module [storeB]
$in ( I : $uint<8>   J : $uint<8>   wval : $uint<32>  )
$out ()
$is
{
  B[I][J] := wval $buffering 1// bits of buffering = 32. 
}
// Memory space 0: A 
// Memory space 1: B 
// Memory space 2: C_temp 
// use of gated clocks in modules 
